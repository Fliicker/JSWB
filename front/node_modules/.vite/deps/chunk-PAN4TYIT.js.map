{
  "version": 3,
  "sources": ["../../@turf/helpers/dist/es/index.js"],
  "sourcesContent": ["/**\r\n * @module helpers\r\n */\r\n/**\r\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\r\n *\r\n * @memberof helpers\r\n * @type {number}\r\n */\r\nexport var earthRadius = 6371008.8;\r\n/**\r\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport var factors = {\r\n    centimeters: earthRadius * 100,\r\n    centimetres: earthRadius * 100,\r\n    degrees: earthRadius / 111325,\r\n    feet: earthRadius * 3.28084,\r\n    inches: earthRadius * 39.37,\r\n    kilometers: earthRadius / 1000,\r\n    kilometres: earthRadius / 1000,\r\n    meters: earthRadius,\r\n    metres: earthRadius,\r\n    miles: earthRadius / 1609.344,\r\n    millimeters: earthRadius * 1000,\r\n    millimetres: earthRadius * 1000,\r\n    nauticalmiles: earthRadius / 1852,\r\n    radians: 1,\r\n    yards: earthRadius * 1.0936,\r\n};\r\n/**\r\n * Units of measurement factors based on 1 meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport var unitsFactors = {\r\n    centimeters: 100,\r\n    centimetres: 100,\r\n    degrees: 1 / 111325,\r\n    feet: 3.28084,\r\n    inches: 39.37,\r\n    kilometers: 1 / 1000,\r\n    kilometres: 1 / 1000,\r\n    meters: 1,\r\n    metres: 1,\r\n    miles: 1 / 1609.344,\r\n    millimeters: 1000,\r\n    millimetres: 1000,\r\n    nauticalmiles: 1 / 1852,\r\n    radians: 1 / earthRadius,\r\n    yards: 1.0936133,\r\n};\r\n/**\r\n * Area of measurement factors based on 1 square meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport var areaFactors = {\r\n    acres: 0.000247105,\r\n    centimeters: 10000,\r\n    centimetres: 10000,\r\n    feet: 10.763910417,\r\n    hectares: 0.0001,\r\n    inches: 1550.003100006,\r\n    kilometers: 0.000001,\r\n    kilometres: 0.000001,\r\n    meters: 1,\r\n    metres: 1,\r\n    miles: 3.86e-7,\r\n    millimeters: 1000000,\r\n    millimetres: 1000000,\r\n    yards: 1.195990046,\r\n};\r\n/**\r\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\r\n *\r\n * @name feature\r\n * @param {Geometry} geometry input geometry\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature} a GeoJSON Feature\r\n * @example\r\n * var geometry = {\r\n *   \"type\": \"Point\",\r\n *   \"coordinates\": [110, 50]\r\n * };\r\n *\r\n * var feature = turf.feature(geometry);\r\n *\r\n * //=feature\r\n */\r\nexport function feature(geom, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var feat = { type: \"Feature\" };\r\n    if (options.id === 0 || options.id) {\r\n        feat.id = options.id;\r\n    }\r\n    if (options.bbox) {\r\n        feat.bbox = options.bbox;\r\n    }\r\n    feat.properties = properties || {};\r\n    feat.geometry = geom;\r\n    return feat;\r\n}\r\n/**\r\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\r\n * For GeometryCollection type use `helpers.geometryCollection`\r\n *\r\n * @name geometry\r\n * @param {string} type Geometry Type\r\n * @param {Array<any>} coordinates Coordinates\r\n * @param {Object} [options={}] Optional Parameters\r\n * @returns {Geometry} a GeoJSON Geometry\r\n * @example\r\n * var type = \"Point\";\r\n * var coordinates = [110, 50];\r\n * var geometry = turf.geometry(type, coordinates);\r\n * // => geometry\r\n */\r\nexport function geometry(type, coordinates, _options) {\r\n    if (_options === void 0) { _options = {}; }\r\n    switch (type) {\r\n        case \"Point\":\r\n            return point(coordinates).geometry;\r\n        case \"LineString\":\r\n            return lineString(coordinates).geometry;\r\n        case \"Polygon\":\r\n            return polygon(coordinates).geometry;\r\n        case \"MultiPoint\":\r\n            return multiPoint(coordinates).geometry;\r\n        case \"MultiLineString\":\r\n            return multiLineString(coordinates).geometry;\r\n        case \"MultiPolygon\":\r\n            return multiPolygon(coordinates).geometry;\r\n        default:\r\n            throw new Error(type + \" is invalid\");\r\n    }\r\n}\r\n/**\r\n * Creates a {@link Point} {@link Feature} from a Position.\r\n *\r\n * @name point\r\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Point>} a Point feature\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n *\r\n * //=point\r\n */\r\nexport function point(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (!coordinates) {\r\n        throw new Error(\"coordinates is required\");\r\n    }\r\n    if (!Array.isArray(coordinates)) {\r\n        throw new Error(\"coordinates must be an Array\");\r\n    }\r\n    if (coordinates.length < 2) {\r\n        throw new Error(\"coordinates must be at least 2 numbers long\");\r\n    }\r\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\r\n        throw new Error(\"coordinates must contain numbers\");\r\n    }\r\n    var geom = {\r\n        type: \"Point\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\r\n *\r\n * @name points\r\n * @param {Array<Array<number>>} coordinates an array of Points\r\n * @param {Object} [properties={}] Translate these properties to each Feature\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Point>} Point Feature\r\n * @example\r\n * var points = turf.points([\r\n *   [-75, 39],\r\n *   [-80, 45],\r\n *   [-78, 50]\r\n * ]);\r\n *\r\n * //=points\r\n */\r\nexport function points(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return featureCollection(coordinates.map(function (coords) {\r\n        return point(coords, properties);\r\n    }), options);\r\n}\r\n/**\r\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\r\n *\r\n * @name polygon\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Polygon>} Polygon Feature\r\n * @example\r\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\r\n *\r\n * //=polygon\r\n */\r\nexport function polygon(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\r\n        var ring = coordinates_1[_i];\r\n        if (ring.length < 4) {\r\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\r\n        }\r\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\r\n            // Check if first point of Polygon contains two numbers\r\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\r\n                throw new Error(\"First and last Position are not equivalent.\");\r\n            }\r\n        }\r\n    }\r\n    var geom = {\r\n        type: \"Polygon\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\r\n *\r\n * @name polygons\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\r\n * @example\r\n * var polygons = turf.polygons([\r\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\r\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\r\n * ]);\r\n *\r\n * //=polygons\r\n */\r\nexport function polygons(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return featureCollection(coordinates.map(function (coords) {\r\n        return polygon(coords, properties);\r\n    }), options);\r\n}\r\n/**\r\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\r\n *\r\n * @name lineString\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<LineString>} LineString Feature\r\n * @example\r\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\r\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\r\n *\r\n * //=linestring1\r\n * //=linestring2\r\n */\r\nexport function lineString(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (coordinates.length < 2) {\r\n        throw new Error(\"coordinates must be an array of two or more positions\");\r\n    }\r\n    var geom = {\r\n        type: \"LineString\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\r\n *\r\n * @name lineStrings\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\r\n * @example\r\n * var linestrings = turf.lineStrings([\r\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\r\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\r\n * ]);\r\n *\r\n * //=linestrings\r\n */\r\nexport function lineStrings(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return featureCollection(coordinates.map(function (coords) {\r\n        return lineString(coords, properties);\r\n    }), options);\r\n}\r\n/**\r\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\r\n *\r\n * @name featureCollection\r\n * @param {Feature[]} features input features\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {FeatureCollection} FeatureCollection of Features\r\n * @example\r\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\r\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\r\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\r\n *\r\n * var collection = turf.featureCollection([\r\n *   locationA,\r\n *   locationB,\r\n *   locationC\r\n * ]);\r\n *\r\n * //=collection\r\n */\r\nexport function featureCollection(features, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var fc = { type: \"FeatureCollection\" };\r\n    if (options.id) {\r\n        fc.id = options.id;\r\n    }\r\n    if (options.bbox) {\r\n        fc.bbox = options.bbox;\r\n    }\r\n    fc.features = features;\r\n    return fc;\r\n}\r\n/**\r\n * Creates a {@link Feature<MultiLineString>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiLineString\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiLineString>} a MultiLineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\r\n *\r\n * //=multiLine\r\n */\r\nexport function multiLineString(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"MultiLineString\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Creates a {@link Feature<MultiPoint>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPoint\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPoint>} a MultiPoint feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\r\n *\r\n * //=multiPt\r\n */\r\nexport function multiPoint(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"MultiPoint\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Creates a {@link Feature<MultiPolygon>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPolygon\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPolygon>} a multipolygon feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\r\n *\r\n * //=multiPoly\r\n *\r\n */\r\nexport function multiPolygon(coordinates, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"MultiPolygon\",\r\n        coordinates: coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Creates a {@link Feature<GeometryCollection>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name geometryCollection\r\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\r\n * @example\r\n * var pt = turf.geometry(\"Point\", [100, 0]);\r\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\r\n * var collection = turf.geometryCollection([pt, line]);\r\n *\r\n * // => collection\r\n */\r\nexport function geometryCollection(geometries, properties, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom = {\r\n        type: \"GeometryCollection\",\r\n        geometries: geometries,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n/**\r\n * Round number to precision\r\n *\r\n * @param {number} num Number\r\n * @param {number} [precision=0] Precision\r\n * @returns {number} rounded number\r\n * @example\r\n * turf.round(120.4321)\r\n * //=120\r\n *\r\n * turf.round(120.4321, 2)\r\n * //=120.43\r\n */\r\nexport function round(num, precision) {\r\n    if (precision === void 0) { precision = 0; }\r\n    if (precision && !(precision >= 0)) {\r\n        throw new Error(\"precision must be a positive number\");\r\n    }\r\n    var multiplier = Math.pow(10, precision || 0);\r\n    return Math.round(num * multiplier) / multiplier;\r\n}\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name radiansToLength\r\n * @param {number} radians in radians across the sphere\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} distance\r\n */\r\nexport function radiansToLength(radians, units) {\r\n    if (units === void 0) { units = \"kilometers\"; }\r\n    var factor = factors[units];\r\n    if (!factor) {\r\n        throw new Error(units + \" units is invalid\");\r\n    }\r\n    return radians * factor;\r\n}\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name lengthToRadians\r\n * @param {number} distance in real units\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} radians\r\n */\r\nexport function lengthToRadians(distance, units) {\r\n    if (units === void 0) { units = \"kilometers\"; }\r\n    var factor = factors[units];\r\n    if (!factor) {\r\n        throw new Error(units + \" units is invalid\");\r\n    }\r\n    return distance / factor;\r\n}\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\r\n *\r\n * @name lengthToDegrees\r\n * @param {number} distance in real units\r\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} degrees\r\n */\r\nexport function lengthToDegrees(distance, units) {\r\n    return radiansToDegrees(lengthToRadians(distance, units));\r\n}\r\n/**\r\n * Converts any bearing angle from the north line direction (positive clockwise)\r\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\r\n *\r\n * @name bearingToAzimuth\r\n * @param {number} bearing angle, between -180 and +180 degrees\r\n * @returns {number} angle between 0 and 360 degrees\r\n */\r\nexport function bearingToAzimuth(bearing) {\r\n    var angle = bearing % 360;\r\n    if (angle < 0) {\r\n        angle += 360;\r\n    }\r\n    return angle;\r\n}\r\n/**\r\n * Converts an angle in radians to degrees\r\n *\r\n * @name radiansToDegrees\r\n * @param {number} radians angle in radians\r\n * @returns {number} degrees between 0 and 360 degrees\r\n */\r\nexport function radiansToDegrees(radians) {\r\n    var degrees = radians % (2 * Math.PI);\r\n    return (degrees * 180) / Math.PI;\r\n}\r\n/**\r\n * Converts an angle in degrees to radians\r\n *\r\n * @name degreesToRadians\r\n * @param {number} degrees angle between 0 and 360 degrees\r\n * @returns {number} angle in radians\r\n */\r\nexport function degreesToRadians(degrees) {\r\n    var radians = degrees % 360;\r\n    return (radians * Math.PI) / 180;\r\n}\r\n/**\r\n * Converts a length to the requested unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @param {number} length to be converted\r\n * @param {Units} [originalUnit=\"kilometers\"] of the length\r\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\r\n * @returns {number} the converted length\r\n */\r\nexport function convertLength(length, originalUnit, finalUnit) {\r\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\r\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\r\n    if (!(length >= 0)) {\r\n        throw new Error(\"length must be a positive number\");\r\n    }\r\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\r\n}\r\n/**\r\n * Converts a area to the requested unit.\r\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\r\n * @param {number} area to be converted\r\n * @param {Units} [originalUnit=\"meters\"] of the distance\r\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\r\n * @returns {number} the converted area\r\n */\r\nexport function convertArea(area, originalUnit, finalUnit) {\r\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\r\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\r\n    if (!(area >= 0)) {\r\n        throw new Error(\"area must be a positive number\");\r\n    }\r\n    var startFactor = areaFactors[originalUnit];\r\n    if (!startFactor) {\r\n        throw new Error(\"invalid original units\");\r\n    }\r\n    var finalFactor = areaFactors[finalUnit];\r\n    if (!finalFactor) {\r\n        throw new Error(\"invalid final units\");\r\n    }\r\n    return (area / startFactor) * finalFactor;\r\n}\r\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isNumber(123)\r\n * //=true\r\n * turf.isNumber('foo')\r\n * //=false\r\n */\r\nexport function isNumber(num) {\r\n    return !isNaN(num) && num !== null && !Array.isArray(num);\r\n}\r\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isObject({elevation: 10})\r\n * //=true\r\n * turf.isObject('foo')\r\n * //=false\r\n */\r\nexport function isObject(input) {\r\n    return !!input && input.constructor === Object;\r\n}\r\n/**\r\n * Validate BBox\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox to validate\r\n * @returns {void}\r\n * @throws Error if BBox is not valid\r\n * @example\r\n * validateBBox([-180, -40, 110, 50])\r\n * //=OK\r\n * validateBBox([-180, -40])\r\n * //=Error\r\n * validateBBox('Foo')\r\n * //=Error\r\n * validateBBox(5)\r\n * //=Error\r\n * validateBBox(null)\r\n * //=Error\r\n * validateBBox(undefined)\r\n * //=Error\r\n */\r\nexport function validateBBox(bbox) {\r\n    if (!bbox) {\r\n        throw new Error(\"bbox is required\");\r\n    }\r\n    if (!Array.isArray(bbox)) {\r\n        throw new Error(\"bbox must be an Array\");\r\n    }\r\n    if (bbox.length !== 4 && bbox.length !== 6) {\r\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\r\n    }\r\n    bbox.forEach(function (num) {\r\n        if (!isNumber(num)) {\r\n            throw new Error(\"bbox must only contain numbers\");\r\n        }\r\n    });\r\n}\r\n/**\r\n * Validate Id\r\n *\r\n * @private\r\n * @param {string|number} id Id to validate\r\n * @returns {void}\r\n * @throws Error if Id is not valid\r\n * @example\r\n * validateId([-180, -40, 110, 50])\r\n * //=Error\r\n * validateId([-180, -40])\r\n * //=Error\r\n * validateId('Foo')\r\n * //=OK\r\n * validateId(5)\r\n * //=OK\r\n * validateId(null)\r\n * //=Error\r\n * validateId(undefined)\r\n * //=Error\r\n */\r\nexport function validateId(id) {\r\n    if (!id) {\r\n        throw new Error(\"id is required\");\r\n    }\r\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\r\n        throw new Error(\"id must be a number or a string\");\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
